# main()
snippet main
	int main(int argc, const char *argv[])
	{
		${1}
		return 0;
	}
# #include <...>
snippet inc
	#include <${1:stdio}.h>${2}
# #include "..."
snippet Inc
	#include "${1:`Filename("$1.h")`}"${2}
# #ifndef ... #define ... #endif
snippet Def
	#ifndef $1
	#define ${1:SYMBOL} ${2:value}
	#endif${3}
snippet def
	#define 
snippet ifdef
	#ifdef ${1:FOO}
		${2:#define }
	#endif
snippet #if
	#if ${1:FOO}
		${2}
	#endif
# Header Include-Guard
# (the randomizer code is taken directly from TextMate; it could probably be
# cleaner, I don't know how to do it in vim script)
snippet once
	#ifndef ${1:`toupper(Filename('', 'UNTITLED').'_'.system("/usr/bin/ruby -e 'print (rand * 2821109907455).round.to_s(36)'"))`}

	#define $1

	${2}

	#endif /* end of include guard: $1 */
# If Condition
snippet if
	if (${1:/* condition */}) 
	{
		${2:/* code */}
	}
snippet el
	else 
	{
		${1}
	}
# Tertiary conditional
snippet t
	${1:/* condition */} ? ${2:a} : ${3:b}
# Do While Loop
snippet do
	do 
	{
		${2:/* code */}
	} while(${1:/* condition */});
# While Loop
snippet wh
	while(${1:/* condition */}) 
	{
		${2:/* code */}
	}
# For Loop
snippet for
	for(${2:i} = 0; $2 < ${1:count}; $2${3:++}) 
	{
		${4:/* code */}
	}
# Custom For Loop
snippet forr
	for(${1:int} ${2:i} = ${3:0}; ${4:$1 < 10}; $2${5:++}) 
	{
		${6:/* code */}
	}
# Function
snippet fun
	${1:void} ${2:function_name}(${3})
	{
		${4:/* code */}
	}
# Function Declaration
snippet fund
	${1:void} ${2:function_name}(${3});${4}
# Typedef
snippet td
	typedef ${1:int} ${2:MyCustomType};${3}
# Struct
snippet st
	struct ${1:`Filename('$1_t', 'name')`} 
	{
		${2:/* data */}
	}${3: /* optional variable list */};${4}
# Typedef struct
snippet tds
	typedef struct ${2:_$1 }
	{
		${3:/* data */}
	} ${1:`Filename('$1_t', 'name')`};
# Typdef enum
snippet tde
	typedef enum 
	{
		${1:/* data */}
	} ${2:foo};

snippet iset
	#include <set>
#########################
#   CPLANE
#########################
snippet typedevent
	UecTypedEvent<UEC_UEM_ReestablishSueReq> l_event(UEC_UEM_REESTABLISH_SUE_TRIGGER, UEC_UE_SPECIFIC, m_ue->getManagerMock().getInstanceId());
snippet typedeventasn
	boost::shared_ptr<SS1apUFERABSetupRequest> l_erabSetupRequest = boost::make_shared<SS1apUFERABSetupRequest>();
	UecTypedEvent<TUP_L3MessageInd, SS1apUFERABSetupRequest> l_event(TUPC_L3S1_MESSAGE_IND_MSG, UEC_UE_SPECIFIC, m_ue->getManagerMock().getInstanceId(), S1AP_E_RAB_SETUP_REQUEST, l_erabSetupRequest);
snippet gennotify
	UEC_GEN_NotifyInfo l_genNotifyInfo = UEC_GEN_NotifyInfo(UEC_CONNECTIVITY_MAC, UEC_UE_SPECIFIC, m_instanceId, p_status);
	UecTypedEvent<UEC_GEN_NotifyInfo> l_event(UEC_GEN_NOTIFY, UEC_UE_SPECIFIC, m_instanceId, l_genNotifyInfo);

#########################
#   DEBUG LOGS
#########################

snippet deb
	CPLANE_DEBUG(__LINE__) << __FUNCTION__ <<"() ${1:debug }";
snippet debug
	CPLANE_DEBUG(__LINE__) << __FUNCTION__ <<"() ${1:debug }";
snippet DEBUG
	CPLANE_DEBUG(__LINE__) << ${1: __FUNCTION__ };
snippet dupa
	CPLANE_DEBUG(__LINE__) << ${1: __FUNCTION__ } << "DUPALOG";
snippet DUPA
	CPLANE_DEBUG(__LINE__) << ${1: __FUNCTION__ } << "DUPALOG";

snippet wrn
	CPLANE_WARN(__LINE__) << __FUNCTION__ <<"() ${1:warn }";
snippet warn
	CPLANE_WARN(__LINE__) << __FUNCTION__ <<"() ${1:warn }";

snippet err
	CPLANE_ERROR(__LINE__) << __FUNCTION__ <<"() ${1:warn }";
snippet error
	CPLANE_ERROR(__LINE__) << __FUNCTION__ <<"() ${1:warn }";

snippet info
	CPLANE_INFO(__LINE__) << __FUNCTION__ <<"() ${1:info }";

snippet name
	namespace ${1:namespace}
	{
	} //${1}

snippet switch
	switch(${1:condition})
	{
		case ${2:value}:
		{
			break;
		}
		default:
		{
		}
	}



snippet ifor_each
	#include <algorithm>
snippet for_each
	for_each(v.begin(), v.end(), func);

snippet itrim
	#include <boost/algorithm/string.hpp>
snippet trim
	trim_if(word, boost::is_any_of("?!"));

snippet fileread
	ifstream file("filename");
	string word;
	while(file>>word)
	{
		word something something;
	}
	file.close()

#########################
# STL Snippets
#########################
snippet imax
	#include <limits>
snippet max
	std::numeric_limits<${1:type}>::max()
snippet imin
	#include <limits>
snippet min
	std::numeric_limits<${1:type}>::min()
#########################
# BOOST Snippets
#########################
snippet ioptional
	#include <boost/optional.hpp>

snippet optional
	boost::optional

snippet ibind
	#include <boost/bind.hpp>
snippet bind
	boost::bind(&${1:type}::${2:func}, ${3:member}, _1)

snippet iforeach
	#include <algorithm>
snippet foreach
	BOOST_FOREACH(${1:type&} elem, ${2:container})
	{
	
	}

snippet ilistof
	#include <boost/assign/list_of.hpp>
snippet ilist_of
	#include <boost/assign/list_of.hpp>
snippet listof
	boost::assign::list_of(${1:value})(${2:value})
snippet list_of
	boost::assign::list_of(${1:value})(${2:value})
snippet hlistof
	#include <boost/assign/list_of.hpp>
	std::vector<int> v = boost::assign::list_of(${1:value})(${2:value});
snippet hlist_of
	#include <boost/assign/list_of.hpp>
	std::vector<int> v = boost::assign::list_of(${1:value})(${2:value});
snippet assign
	boost::assign::list_of(${1:value})(${2:value})
snippet hassign
	#include <boost/assign/list_of.hpp>
	std::vector<int> v = boost::assign::list_of(${1:value})(${2:value});

snippet imakeshared
	#include <boost/make_shared.hpp>
snippet imake_shared
	#include <boost/make_shared.hpp>
snippet make_shared
	boost::make_shared<${1:type}>(${2:ctor_param},${3:ctor_param2})
snippet hmake_shared
	#include <boost/make_shared.hpp>
	boost::make_shared<${1:type}>(${2:ctor_param},${3:ctor_param2})

snippet ishared
	#include <boost/shared_ptr.hpp>
snippet shared
	boost::shared_ptr<${1:type}>

snippet ifunction
	#include <boost/function.hpp>
snippet function
	boost::function<${1:type(params)}> ${2:p_func}
snippet hfunction
	typedef boost::function<${1:Meas::RrcMeasIdOpt(const UecIUeContextData&)}> FindActiveInterFreqRscMeasId;
	boost::FindActiveInterFreqRscMeasId p_func = ${2:&Meas::findInterFreqRscActiveMeasId}

snippet ituple
	#include "boost/tuple/tuple.hpp"
snippet htuple
	typedef boost::tuple <bool, bool> BoolPair
	BoolPair l_pair = boost::make_tuple(true, false);


#########################
#    TESTS
#########################
snippet MATCHER_P
	MATCHER_P(${1:WithMatchingType}, ${2:expected}, "${3:description}")
	{
	    return ${4:arg};
	}
snippet matcher
	MATCHER_P(${1:WithMatchingType}, ${2:expected}, "${3:description}")
	{
	    return ${4:arg};
	}

snippet TestWithParam
	typedef boost::tuple<bool, bool> param;
	class TestSuite : public TestWithParam<param>
	{
	public:
	    TestSuite();
	
	    const bool flag1;
	    const bool flag2;
	};
	
	
	INSTANTIATE_TEST_CASE_P(
	    TestSuiteParametrized,
	    TestSuite,
	    testing::Values(                 // flag1, flag2
	           boost::make_tuple(true,  false),
	           boost::make_tuple(false, true)));
	
	TestSuite::TestSuite() :
	        flag1(boost::get<0>(GetParam())),
	        flag2(boost::get<1>(GetParam())) {}
	
	TEST_P(RscBlockedByOtherMeasurementsCheckerTestSuite, testRscBlockedByOtherMeasurements)
	{
	}

snippet WithParamInterface
	class BaseTest : public ::testing::Test 
	{
	};
	class BarTest : public BaseTest,
	                public ::testing::WithParamInterface<Param>
	{
	};
	TEST_P(BarTest, test)
	{
	}
	
	INSTANTIATE_TEST_CASE_P(
	    BarTestParametrized,
	    BarTest,
	    testing::Values(
	        Bar(foo, true),
	        Bar(foo, false)
	    ));


#########################
#    OTHER
#########################

snippet head
	/**
	*******************************************************************************
	* @file                  $HeadURL$
	* @version               $LastChangedRevision$
	* @date                  $LastChangedDate$
	* @author                $Author$
	*
	* Copyright 2014 Nokia Siemens Networks. All rights reserved.
	*******************************************************************************/
